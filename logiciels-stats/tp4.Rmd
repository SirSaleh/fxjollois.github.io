---
title: Rendu du TP4
author: "FX Jollois"
date: "1 avril 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
library(knitr)
library(FactoMineR)
```

## Les données

Nous allons reprendre sur le jeu de données `us_data` disponible dans la librairie `sashelp` de SAS, basé sur les données de l’[US Census 2010](http://www.census.gov/2010census/data/).

```{r donnees, echo = TRUE}
us = read.table("US_DATA.csv", header = T)
```

```{r donnees-head, results='asis'}
kable(head(us))
```

## Analyser les états en fonction de leur population

On se retreint ici aux variables `POPULATION_xxx`. Nous créons un `data.frame` spécifique.

```{r population, echo = TRUE}
us_pop = us[grep("POPULATION", names(us))]
rownames(us_pop) = us$STATENAME
```

```{r population-head, results='asis'}
kable(head(us_pop))
```

###   d’une ACP (essayer avec standardisation et sans)

#### Avec standardisation

La fonction `PCA()` du package `FactoMineR` exécute directement une ACP sur les données standardisées. Nous n'avons rien d'autres à spécifier.

```{r pop-acp1, echo = TRUE}
acp1 = PCA(us_pop, graph = FALSE)
```

Comme le montre le graphique ci-dessous, seules les deux premières dimensions sont à utiliser (contenant plus de 99.5 %  de l'information).

```{r pop-acp1-barplot, fig.cap = "Valeurs propres"}
par(mar = c(2, 4, 0, 0) + .1)
barplot(acp1$eig[,1], 
        names.arg = 1:ncol(us_pop),
        cex.names = .8,
        ylab = "Valeur propre",
        cex.lab = .8)
abline(h = 1, lty = 2, col = "gray50")
```

Nous voyons quelques états se détachant (les 5 plus peuplés en moyenne).

```{r pop-acp1-plot-ind, fig.cap = "Représentation des états"}
par(mar = c(4, 4, 0, 0) + .1)
lab = rownames(us_pop)
lab[acp1$ind$dist < 5] = ""
plot(acp1$ind$coord,
     xlim = c(-7.5, 17.5),
     ylim = c(-3, 6.5),
     pch = 19,
     col = c("gray40", "gray70")[(lab == "") + 1],
     xlab = "Dimension 1 (88.9 %)",
     ylab = "Dimension 2 (10.6 %)",
     cex.lab = .8)
text(acp1$ind$coord, lab, 
     adj = c(.5,-1), cex = .6)
abline(h = 0, lty = 3, col = "gray50")
abline(v = 0, lty = 3, col = "gray50")
```

Ici, nous voyons un effet *Guttman*, avec les années correctement ordonnées sur l'axe 2.

```{r pop-acp1-plot-var, fig.cap = "Représentation des années"}
par(mar = c(4, 4, 0, 0) + .1)
lab = names(us_pop)
plot(acp1$var$coord,
     xlim = c(-1, 1),
     ylim = c(-1, 1),
     pch = 19,
     col = "gray40",
     xlab = "Dimension 1 (88.9 %)",
     ylab = "Dimension 2 (10.6 %)",
     cex.lab = .8)
text(acp1$var$coord, 
     substr(lab, 12, 15), 
     adj = c(1.5,0), cex = .8)
abline(h = 0, lty = 3, col = "gray50")
abline(v = 0, lty = 3, col = "gray50")
```

Si nous regardons les évolutions sur le siècle dernier (cf figure ci-après), nous voyons que la Californie, et le Texas sont les états ayant le plus progressés en population sur la période analysée.

```{r pop-evol}
par(mar = c(2, 0, 0, 0) + .1)
etats = rownames(us_pop)[acp1$ind$dist > 5]
annees = seq(1910, 2010, by = 10)
couleurs = rainbow(length(etats))
names(couleurs) = etats
plot(NULL, NULL, 
     xlim = c(1910, 2050),
     ylim = c(0, max(us_pop / 1000)),
     axes = F)
axis(1, at = annees, 
     lwd = 0, lwd.ticks = .5,
     cex.axis = .6)
for (e in etats) {
    v = unlist(us_pop[e,] / 1000)
    lines(annees,
          v,
          col = couleurs[e])
    text(2015,
         tail(v, 1),
         e, col = couleurs[e],
         adj = c(0, .5),
         cex = .8)
}
```

#### Sans standardisation

Ici, les valeurs sont divisées par 10000000 pour améliorer la lisibilité des graphiques, les comparaisons étant bien évidemment identiques.

```{r pop-acp2, echo = TRUE}
acp2 = PCA(us_pop / 1000000, graph = FALSE, scale.unit = FALSE)
```

```{r pop-acp2-barplot, fig.cap = "Valeurs propres"}
par(mar = c(2, 4, 0, 0) + .1)
barplot(acp2$eig[,1], 
        names.arg = 1:ncol(us_pop),
        cex.names = .8,
        ylab = "Valeur propre",
        cex.lab = .8)
abline(h = 1, lty = 2, col = "gray50")
```

```{r pop-acp2-plot-ind, fig.cap = "Représentation des états"}
par(mar = c(4, 4, 0, 0) + .1)
lab = rownames(us_pop)
lab[acp2$ind$dist < 12] = ""
plot(acp2$ind$coord,
     xlim = c(-15, 60),
     ylim = c(-30, 30),
     pch = 19,
     col = c("gray40", "gray70")[(lab == "") + 1],
     xlab = "Dimension 1 (92.8 %)",
     ylab = "Dimension 2 (6.8 %)",
     cex.lab = .8)
text(acp2$ind$coord, lab, 
     adj = c(.5,-1), cex = .6)
abline(h = 0, lty = 3, col = "gray50")
abline(v = 0, lty = 3, col = "gray50")
```

```{r pop-acp2-plot-var, fig.cap = "Représentation des années"}
par(mar = c(4, 4, 0, 0) + .1)
lab = names(us_pop)
plot(acp2$var$coord,
     xlim = c(0, 8),
     ylim = c(-3, 3),
     pch = 19,
     col = "gray40",
     xlab = "Dimension 1 (92.8 %)",
     ylab = "Dimension 2 (6.8 %)",
     cex.lab = .8)
text(acp2$var$coord, 
     substr(lab, 12, 15), 
     adj = c(.5,-1.5), cex = .8)
abline(h = 0, lty = 3, col = "gray50")
abline(v = 0, lty = 3, col = "gray50")
```

###   d’une AFC

## Faire de même pour la densité (variables DENSITY_xxxx)

## Faire une partition en un nombre de classes adapté sur chaque ensemble de données précédent

###   Choisir le nombre de classes à l’aide de la CAH et de $k$-means (avec $r^2$ et $PseudoF$)

###   Prendre la partition obtenue avec $k$-means (et le nombre de classes choisi)

### Comparer les deux partitions obtenues entre elles, et avec les régions et les divisions présentes dans les données
