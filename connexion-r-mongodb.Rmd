---
title: Connexion entre `R` et MongoDB
subtitle: DU Analyste Big Data
---

Dans ce document est l'utilisation du package `rmongodb` et `mongolite` permettant la connection à une base de données [MongoDB]().

## `R` et MongoDB

Les résultats des commandes suivantes ne sont pas présentés dans ce document car le serveur MongoDB n'est accessible que depuis l'IUT.

### Connexion

Pour interroger MongoDB dans `R`, il faut créer une connexion entre les deux. Ici, je créé une connexion au serveur local sur ma machine. A l'IUT, l'adresse du serveur MongoDB est : `172.19.32.10`.

```{r eval=FALSE}
library(rmongodb)
conn = mongo.create(host = "127.0.0.1")
mongo.is.connected(conn)
```

### Récupération d'informations simples

Une fois cette connexion créée, il est possible de regarder quelles sont les bases de données contenues, ainsi que les collections présentes dans ces BD. .

```{r eval=FALSE}
mongo.get.databases(conn)
mongo.get.database.collections(conn, "gym")
# Nombre d'enregistrement de la collection Sportifs de la BD gym
mongo.count(conn, "gym.Sportifs")
```

#### Premier enregistrement d'une collection

Dans Mongo, il n'y a pas de schéma pour une base de données, ni même pour une collection. Un moyen de s'approprier les données est donc de regarder le premier élément. C'est pourquoi il existe la fonction `mongo.findOne()`.

```{r eval=FALSE}
# Premier enregistrement de la collection Sportifs de la BD gym
mongo.findOne(conn, "gym.Sportifs")
# Idem mais converti en liste
mongo.bson.to.list(mongo.findOne(conn, "gym.Sportifs"))
```

sur cet enregistrement, on peut vouloir avoir accès aux données directement. Une première façon de faire est de garder l'enregistrement au format `bson`.

```{r eval=FALSE}
enr1 = mongo.findOne(conn, "gym.Sportifs")
mongo.bson.value(enr1, "Nom")
mongo.bson.value(enr1, "Sports")
```

Une autre façon de transformer le `bson` en `list` comme précédemment, et de manipuler la liste.

```{r eval=FALSE}
l1 = mongo.bson.to.list(enr1)
l1$Nom
l1$Sports
```

#### Valeurs distinctes d'un élément d'une collection

Puisqu'on n'a pas de schéma, on peut aussi vouloir avoir la liste des valeurs prises par un élément particulier.

```{r eval=FALSE}
# Liste des valeurs prises par l'élement Sexe dans tous les enregistrements de gym.Sportifs
mongo.distinct(conn, "gym.Sportifs", "Sexe")
```

### Interrogation de données

On fait référence ici aussi à l'interrogation de type `SQL`, mais dans un environnement NoSQL (sans schéma explicite, sans stricte égalité de schéma entre les enregistrements, sans jointure).

#### Restriction et projection 

La fonction `mongo.find()` permet de renvoyer tous les enregistements par défaut. Il faut donc la manipuler prudemment si on en a beaucoup. Par contre, elle renvoie un `mongo.cursor` qu'il faut parcourir pour afficher les résultats.

```{r eval=FALSE}
curs = mongo.find(conn, "gym.Sportifs")
while (mongo.cursor.next(curs))
  print(mongo.cursor.value(curs))
```

Pour effectuer une restriction, on utilise le paramètre `query` de la fonction `mongo.find()`. Cette requête doit être une chaîne de caractère, et dans le même format que dans le langage `JS` de la console Mongo.

```{r eval=FALSE}
curs = mongo.find(conn, "gym.Sportifs", query = '{ "Nom": "BOUTAHAR" }')
while (mongo.cursor.next(curs))
  print(mongo.cursor.value(curs))
```

La projection se fait avec le paramètre `fields`, recevant une chaîne de caractère, au format du langage console de Mongo. 

```{r eval=FALSE}
curs = mongo.find(conn, "gym.Sportifs", fields = '{ "Nom": 1, "_id": 0 }')
while (mongo.cursor.next(curs))
  print(mongo.cursor.value(curs))
```

Il est bien évidemment possible de combiner ces deux paramètres pour faire les deux opérations.

```{r eval=FALSE}
curs = mongo.find(conn, "gym.Sportifs", 
                  query = '{ "Sexe": "F"}',
                  fields = '{ "Nom": 1, "_id": 0 }')
while (mongo.cursor.next(curs))
  print(mongo.cursor.value(curs))
```

#### Agrégat

Les agrégats sont effectués avec la fonction `mongo.aggregation()`, dans laquelle on définit un `pipeline` sous forme de `list`, avec une syntaxe proche de celle de Mongo. Les variables de regroupement sont celles indiquées dans le `_id` de l'élement `$group`. Si la valeur est `null`, il regroupe tous les enregistrements.

```{r eval=FALSE}
mongo.aggregation(
  conn, 
  "gym.Sportifs",
  pipeline = list('{ 
                    "$group": { 
                      "_id": "null", 
                      "AgeMoyen": { "$avg": "$Age" }, 
                      "Nb": { "$sum": 1 } 
                    } 
                  }')
)
```

Par contre, si on indique une variable (ici `Sexe` par exemple), il fait le regroupement par modalité, classiquement.

```{r eval=FALSE}
mongo.aggregation(
  conn, 
  "gym.Sportifs",
  pipeline = list('{ 
                    "$group": { 
                      "_id": "$Sexe", 
                      "AgeMoyen": { "$avg": "$Age" }, 
                      "Nb": { "$sum": 1 } 
                    } 
                  }')
)
```

On remarque ici qu'il y a la modalité `m` et la modalité `M`. Pour mettre en majuscule, on peut le définir directement dans la définition de `_id`.

```{r eval=FALSE}
mongo.aggregation(
  conn, 
  "gym.Sportifs",
  pipeline = list('{ 
                    "$group": { 
                      "_id": { "$toUpper" : "$Sexe" }, 
                      "AgeMoyen": { "$avg": "$Age" }, 
                      "Nb": { "$sum": 1 } 
                    } 
                  }')
)
```


#### Calcul

Pour créer des nouveaux éléments dans un enregistrement, il est nécessaire d'utiliser la fonction d'aggrégation, avec `$project`.

```{r eval=FALSE}
mongo.aggregation(
  conn,
  "gym.Sportifs",
  pipeline = list('{
                    "$project": {
                      "_id": 0,
                      "Nom": 1,
                      "Prenom": { "$toLower": "$Prenom" },
                      "Sexe": { "$toUpper": "$Sexe" }
                    }
                  }')
)
```

#### Recherche complexe

Cette commande d'agrégation sert aussi à faire des recherches compexes dans les sous-éléments présents dans les enregistrements.

Par exemple, dans la collection `Gymnases`, nous avons la liste des séances avec les jours et les sports. Si on cherche les jours et les gymnases où il y a des séances de `Hand ball`, la recherche simple comme suit ne suffit pas. On obtient bien les informations voulues, mais on a aussi les séances des gymnases pour les autres sports.

```{r eval=FALSE}
curs = mongo.find(
  conn,
  "gym.Gymnases",
  query = '{ "Seances.Libelle": "Hand ball" }',
  fields = '{ 
    "_id": 0, "NomGymnase": 1, "Ville": 1, "Seances.Jour": 1, "Seances.Libelle": 1 
  }'
)
while (mongo.cursor.next(curs))
  print(mongo.cursor.value(curs))
```

Pour résoudre ce problème, nous allons utilisons la fonction d'aggrégation, avec la commande `$unwind`. Celle-ci permet de séparer les éléments du tableau passé en paramètre. Ici, d'un enregistrement par gymnase, on passe à un enregistrement par gymnase et par séance.

```{r eval=FALSE}
mongo.aggregation(
  conn,
  "gym.Gymnases",
  pipeline = list(
    '{ "$unwind": "$Seances" }'
  )
)
```

Dans le `pipeline`, on peut aussi ajouter des restrictions, avec la commande `$match`. On peut mettre celui-ci avant et/ou après le `$unwind`. Et choisir les éléments retournés avec `$project`. Pour répondre à la question *jours et gymnases où il y a des séances de `Hand ball`*, on peut faire ainsi :

```{r eval=FALSE}
mongo.aggregation(
  conn,
  "gym.Gymnases",
  pipeline = list(
    '{ "$match": { "Seances": { "$elemMatch": { "Libelle": "Hand ball" } } } }',
    '{ "$unwind": "$Seances" }',
    '{ "$match": { "Seances.Libelle": "Hand ball"} }',
    '{ 
      "$group": { 
        "_id": "$NomGymnase", 
        "Jours" : { "$addToSet": { "$toLower": "$Seances.Jour" } } ,
        "Sports" : { "$addToSet": "$Seances.Libelle" }
      } 
    }'
  )
)
```


### Déconnexion

Comme pour toute connexion, il faut déconnecter pour être propre.

```{r eval=FALSE}
mongo.disconnect(conn)
```


